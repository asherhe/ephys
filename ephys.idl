// spec: https://webidl.spec.whatwg.org/

// notes:
// - by default, objects are taken as pointers
//   use [Value] to indicate the object itself
// - int is a long (32 bits)
// - use [NoDelete] for abstract classes as they do not have a destructor

//////// Math ////////

[Prefix="ephys::"]
interface Vec2 {
  attribute float x;
  attribute float y;

  void Vec2();
  void Vec2([Const] float x, [Const] float y);
  void Vec2([Const, Ref] Vec2 x);

  void set([Const] float x, [Const] float y);

  float norm();
  float norm2();
  [Ref] Vec2 normalize();

  [Operator="+=", Ref] Vec2 add([Const, Ref] Vec2 v);
  [Operator="-=", Ref] Vec2 sub([Const, Ref] Vec2 v);
  [Operator="*=", Ref] Vec2 mult(float k);
};

[Prefix="ephys::"]
interface Mat2 {
  attribute float[] data;

  void Mat2();
  void Mat2(float d11, float d12,
            float d21, float d22);
  void Mat2([Const, Ref] Mat2 m);

  [Value] static Mat2 zero();
  [Value] static Mat2 identity();

  float at(unsigned long m, unsigned long n);
  void set(unsigned long m, unsigned long n, float val);

  [Operator="+=", Ref] Mat2 add([Const, Ref] Mat2 m);
  [Operator="-=", Ref] Mat2 sub([Const, Ref] Mat2 m);
  [Operator="*=", Ref] Mat2 mult([Const, Ref] Mat2 m);

  float determinant();

  [Value] Mat2 inverse();
  [Ref] Mat2 invert();

  [Value] Mat2 transpose();
};

[Prefix="ephys::"]
interface Mat3 {
  void Mat3();
  void Mat3(float d11, float d12, float d13,
            float d21, float d22, float d23);
  void Mat3([Const, Ref] Mat3 m);

  [Value] static Mat3 identity();

  float at(unsigned long m, unsigned long n);
  void set(unsigned long m, unsigned long n, float val);

  float determinant();

  [Value] Mat3 inverse();
  [Ref] Mat3 invert();
};

//////// Rigidbodies ////////

[Prefix="ephys::"]
interface Rigidbody {
  void Rigidbody();

  [Value] Vec2 getPos();
  [Value] Vec2 getVel();
  [Value] Vec2 getAcc();
  float getAngle();
  float getAngVel();
  float getMass();
  float getInvMass();
  float getInertia();
  float getInvInertia();
  [Value] Mat3 getTransform();
  [Value] Mat3 getInvTransform();

  void setPos([Const, Ref] Vec2 pos);
  void setVel([Const, Ref] Vec2 vel);
  void setAcc([Const, Ref] Vec2 acc);
  void setAngle(float angle);
  void setAngVel(float angVel);
  void setMass(float mass);
  void setInvMass(float invMass);
  void setInertia(float inertia);
  void setInvInertia(float invInertia);

  [Value] Vec2 world2Local([Const, Ref] Vec2 pos);
  [Value] Vec2 local2World([Const, Ref] Vec2 pos);

  void addForce([Const, Ref] Vec2 force);
  void addForceAt([Const, Ref] Vec2 force, [Const, Ref] Vec2 point);
  void addForceAtLocal([Const, Ref] Vec2 force, [Const, Ref] Vec2 point);

  void addTorque(float torque);

  void clearAccums();

  void step(float dt);
};

//////// Physics World ////////

[Prefix="ephys::"]
interface World {
  void World();

  void addBody([Ref] Rigidbody body);
  void removeBody([Ref] Rigidbody body);

  void step(float dt);
};

//////// Contacts ////////

[Prefix="ephys::", NoDelete]
interface Contact {
  attribute Rigidbody[] bodies;
  [Value] attribute Vec2 contactPoint;
  [Value] attribute Vec2 normal;
  attribute float penetration;
  attribute float restitution;

  void Contact();
};

//////// Collision ////////

[Prefix="ephys::", NoDelete]
interface BoundingVolume {
  boolean overlaps([Const, Ref] BoundingVolume bv);
  float size();
  float growth([Const, Ref] BoundingVolume bv);
};

[Prefix="ephys::"]
interface BoundingCircle : BoundingVolume {
  [Value] attribute Vec2 center;
  attribute float radius;

  void BoundingCircle([Const, Ref] Vec2 center, float radius);
  // void BoundingCircle([Const, Ref] BoundingCircle b1, [Const, Ref] BoundingCircle b2);
  boolean overlaps([Const, Ref] BoundingVolume bc);
  float size();
  float growth([Const, Ref] BoundingVolume bc);
};

[Prefix="ephys::"]
interface PotentialContact {
  attribute Rigidbody[] bodies;

  void PotentialContact([Ref] Rigidbody b1, [Ref] Rigidbody b2);
};

[NoDelete]
interface BVHCircleNode {
  attribute Rigidbody body;
  [Value] attribute BoundingCircle volume;
  attribute BVHCircleNode parent;
  attribute BVHCircleNode[] children; 

  void BVHCircleNode([Const, Ref] BoundingCircle volume, Rigidbody body);

  boolean isLeaf();
  boolean overlaps([Const, Ref] BVHCircleNode bvh);

  void insert([Ref] Rigidbody body, [Ref] BoundingCircle volume);
};

[Prefix="ephys::"]
interface CollisionProperties {
  attribute float restitution;
};

[Prefix="ephys::"]
interface Collider {
  attribute Rigidbody body;

  [Value] Vec2 origin();
  [Value] Mat3 getTransform();
  [Value] Mat3 getInvTransform();
  void setTransform([Const, Ref] Mat3 transform);
  void setInvTransform([Const, Ref] Mat3 invTransform);

  [Value] Vec2 collider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 object2Collider([Const, Ref] Vec2 v);
  [Value] Vec2 rotCollider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 rotObject2Collider([Const, Ref] Vec2 v);
};

[Prefix="ephys::"]
interface CircleCollider : Collider {
  attribute float radius;

  void CircleCollider(float radius, [Ref] Rigidbody body, [Const, Ref] optional Mat3 transform);

  attribute Rigidbody body;

  [Value] Vec2 origin();
  [Value] Mat3 getTransform();
  [Value] Mat3 getInvTransform();
  void setTransform([Const, Ref] Mat3 transform);
  void setInvTransform([Const, Ref] Mat3 invTransform);

  [Value] Vec2 collider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 object2Collider([Const, Ref] Vec2 v);
  [Value] Vec2 rotCollider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 rotObject2Collider([Const, Ref] Vec2 v);
};

[Prefix="ephys::"]
interface BoxCollider : Collider {
  [Value] attribute Vec2 halfSize;

  void BoxCollider([Const, Ref] Vec2 halfSize, [Ref] Rigidbody body, [Const, Ref] optional Mat3 transform);

  attribute Rigidbody body;

  [Value] Vec2 origin();
  [Value] Mat3 getTransform();
  [Value] Mat3 getInvTransform();
  void setTransform([Const, Ref] Mat3 transform);
  void setInvTransform([Const, Ref] Mat3 invTransform);

  [Value] Vec2 collider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 object2Collider([Const, Ref] Vec2 v);
  [Value] Vec2 rotCollider2Object([Const, Ref] Vec2 v);
  [Value] Vec2 rotObject2Collider([Const, Ref] Vec2 v);
};

[Prefix="ephys::", NoDelete]
interface IntersectionDetector {
  static boolean circleCircle([Const, Ref] CircleCollider c1, [Const, Ref] CircleCollider c2);
  static boolean boxCircle([Const, Ref] BoxCollider bc, [Const, Ref] CircleCollider cc);
  static boolean boxBox([Const, Ref] BoxCollider b1, [Const, Ref] BoxCollider b2);
};

[NoDelete]
interface ContactList {};

[Prefix="ephys::", NoDelete]
interface CollisionDetector {
  [Ref] static ContactList circleCircle([Const, Ref] CircleCollider c1, [Const, Ref] CircleCollider c2, [Const, Ref] CollisionProperties properties);
  [Ref] static ContactList boxCircle([Const, Ref] BoxCollider bc, [Const, Ref] CircleCollider cc, [Const, Ref] CollisionProperties properties);
  [Ref] static ContactList boxBox([Const, Ref] BoxCollider b1, [Const, Ref] BoxCollider b2, [Const, Ref] CollisionProperties properties);
};

//////// Force Generators ////////
[Prefix="ephys::", NoDelete]
interface ForceGenerator {
  void updateForce([Ref] Rigidbody body, float dt);
};

[Prefix="ephys::", NoDelete]
interface ForceRegistry {
  void ForceRegistry();

  void add([Ref] Rigidbody body, [Ref] ForceGenerator fgen);
  void remove([Ref] Rigidbody body, [Ref] ForceGenerator fgen);
  void clear();
};

[Prefix="ephys::"]
interface Gravity : ForceGenerator {
  void Gravity([Const, Ref] Vec2 gravity);
  
  void updateForce([Ref] Rigidbody body, float dt);
};

[Prefix="ephys::"]
interface Spring : ForceGenerator {
  attribute float k;
  attribute float length;

  void Spring([Ref] Rigidbody end, [Const, Ref] Vec2 anchor, [Const, Ref] Vec2 endAnchor, float k, float length);

  [Value] Rigidbody getEnd();
  void setEnd([Const, Ref] Rigidbody body);

  void updateForce([Ref] Rigidbody body, float dt);
};

//////// Particles ////////

[Prefix="ephys::"]
interface Particle {
  void Particle(optional float mass, optional float damping);

  [Value] Vec2 getPos();
  [Value] Vec2 getVel();
  [Value] Vec2 getAcc();
  float getMass();
  float getInvMass();
  float getDamping();

  void setPos([Const, Ref] Vec2 pos);
  void setVel([Const, Ref] Vec2 vel);
  void setAcc([Const, Ref] Vec2 acc);
  void setMass(float mass);
  void setInvMass(float mass);
  void setDamping(float damping);

  void addForce([Const, Ref] Vec2 force);
  void addImpulse([Const, Ref] Vec2 impulse);

  void clearForceAccum();

  void setStatic();
  boolean isStatic();

  void step(float dt);
};

//////// Particle Force Generators ////////

[Prefix="ephys::", NoDelete]
interface ParticleForceGenerator {
  void updateForce([Ref] Particle particle, float dt);
};

[Prefix="ephys::"]
interface ParticleForceRegistry {
  void ParticleForceRegistry();

  void add([Ref] Particle particle, [Ref] ParticleForceGenerator fgen);
  void remove([Ref] Particle particle, [Ref] ParticleForceGenerator fgen);
  void clear();

  void step(float dt);
};

[Prefix="ephys::"]
interface ParticleGravity : ParticleForceGenerator {
  void ParticleGravity([Const, Ref] Vec2 gravity);
  void updateForce([Ref] Particle particle, float dt);
};
[Prefix="ephys::"]
interface ParticleDrag : ParticleForceGenerator {
  void ParticleDrag(float k1, float k2);
  void updateForce([Ref] Particle particle, float dt);
};
[Prefix="ephys::"]
interface ParticleSpring : ParticleForceGenerator {
  attribute float k;
  attribute float length;
  void ParticleSpring([Ref] Particle end, float k, float length);
  void setEnd([Const, Ref] Particle particle);
  [Value] Particle getEnd();
  void updateForce([Ref] Particle particle, float dt);
};

//////// Particle Contacts ////////
[Prefix="ephys::"]
interface ParticleContact {
  attribute Particle[] particles;
  attribute float restitution;
  [Value] attribute Vec2 normal;
  attribute float penetration;

  float separatingVelocity();
};

// placeholder for std::list<ephys::ParticleContact>
[NoDelete]
interface PContactList {};

[Prefix="ephys::"]
interface ParticleContactSolver {
  void ParticleContactSolver(unsigned long maxIterations);

  unsigned long getIterations();
  void setIterations(unsigned long iterations);

  void solveContacts([Ref] PContactList contacts, float dt);
};

[Prefix="ephys::", NoDelete]
interface ParticleContactGenerator {
  [Ref] PContactList generateContacts();
};

//////// Particle Links ////////
[Prefix="ephys::", NoDelete]
interface ParticleLink : ParticleContactGenerator {
  void setParticle(unsigned long index, [Ref] Particle particle);
  [Ref] Particle getParticle(unsigned long index);

  [Ref] PContactList generateContacts();
};

[Prefix="ephys::"]
interface ParticleCable : ParticleLink {
  attribute float length;
  attribute float restitution;

  void ParticleCable(float length, float restitution);
  
  void setParticle(unsigned long index, [Ref] Particle particle);
  [Ref] Particle getParticle(unsigned long index);
  
  [Ref] PContactList generateContacts();
};

[Prefix="ephys::"]
interface ParticleRod : ParticleLink {
  attribute float length;

  void ParticleRod(float length);
  
  void setParticle(unsigned long index, [Ref] Particle particle);
  [Ref] Particle getParticle(unsigned long index);
  
  [Ref] PContactList generateContacts();
};

//////// Particle World ////////
[Prefix="ephys::"]
interface ParticleWorld {
  void ParticleWorld(optional unsigned long iterations);

  void addParticle([Ref] Particle particle);
  void removeParticle([Ref] Particle particle);

  void addPFGen([Ref] Particle particle, [Ref] ParticleForceGenerator fgen);
  void removePFGen([Ref] Particle particle, [Ref] ParticleForceGenerator fgen);

  void addPContactGenerator([Ref] ParticleContactGenerator pcg);
  void removePContactGenerator([Ref] ParticleContactGenerator pcg);
  
  [Ref] PContactList generateContacts();

  void step(float dt);
};
